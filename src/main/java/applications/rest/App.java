/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package applications.rest;

import java.sql.*;
import java.util.*;
import spark.*;
import static spark.Spark.*;
import com.google.gson.Gson;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.nio.charset.StandardCharsets;
import java.math.BigInteger;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;


public class App {

    public static void main(String[] args) {
        Database db = new Database("krusty-kookies.sqlite");
        port(8888);

        // Routes
        post("/reset", (req, res) -> db.reset(req, res));
        get("/movies", (req, res) -> db.getMovies(req, res));
        get("/movies/:id", (req, res) -> db.getMovieById(req, res));
        get("/performances", (req, res) -> db.getPerformances(req, res));
        post("/performances", (req, res) -> db.postPerformances(req, res));
        post("/tickets", (req, res) -> db.postTickets(req, res));
        get("/customers/:id/tickets", (req, res) -> db.getCustomerTickets(req, res));
    }
}



class Database {

    /**
     * The database connection.
     */
    private Connection conn;
    private PasswordHashGenerator phg = new PasswordHashGenerator();

    /**
     * Creates the database interface object. Connection to the
     * database is performed later.
     */
    public Database(String filename) {
        openConnection(filename);
    }

    /**
     * Opens a connection to the database, using the specified
     * filename (if we'd used a traditional DBMS, such as PostgreSQL
     * or MariaDB, we would have specified username and password
     * instead).
     */
    public boolean openConnection(String filename) {
        try {
            Class.forName("org.sqlite.JDBC");
            conn = DriverManager.getConnection("jdbc:sqlite:" + filename);
        } catch (SQLException e) {
            e.printStackTrace();
            return false;
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }

    /**
     * Closes the connection to the database.
     */
    public void closeConnection() {
        try {
            if (conn != null) {
                conn.close();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    /**
     * Checks if the connection to the database has been established
     * 
     * @return true if the connection has been established
     */
    public boolean isConnected() {
        return conn != null;
    }

    /* ================================== */
    /* --- insert your own code below --- */
    /* ===============================*== */

    void insertIntoCustomers(String customer_name, String customer_address) {
        String statement = "INSERT INTO customers (customer_name, customer_address) VALUES (?, ?);";

        try(PreparedStatement ps = conn.prepareStatement(statement)) {
            ps.setString(1, customer_name);
            ps.setString(2, customer_address);
            ps.executeUpdate();
        } catch(SQLException e) {
            e.printStackTrace();
        }
    }

    void insertIntoRecipes(String recipe_name) {
        String statement = "INSERT INTO recipes (recipe_name) VALUES (?);";

        try(PreparedStatement ps = conn.prepareStatement(statement)) {
            ps.setString(1, recipe_name);
            ps.executeUpdate();
        } catch(SQLException e) {
            e.printStackTrace();
        }
    }

    void insertIntoRecipeUsed(String recipe_name, String order_id) {
        String statement = "INSERT INTO recipe_used (recipe_name, order_id) VALUES (?, ?);";

        try(PreparedStatement ps = conn.prepareStatement(statement)) {
            ps.setString(1, recipe_name);
            ps.setString(2, order_id);
            ps.executeUpdate();
        } catch(SQLException e) {
            e.printStackTrace();
        }
    }
    
    
    void insertIntoIngredients(String name, String unit) {
        String statement = "INSERT INTO ingredients (ingredient_name, unit) VALUES (?, ?);";
    
        try(PreparedStatement ps = conn.prepareStatement(statement)) {
            ps.setString(1, name);
            ps.setString(2, unit);
            ps.executeUpdate();
        } catch(SQLException e) {
            e.printStackTrace();
        }
    }

    void insertIntoIngredientsUsed(int amount, String ingredient_name, String recipe_name) {
        String statement = "INSERT INTO ingredients_used (amount, ingredient_name, recipe_name) VALUES (?, ?, ?);";

        try(PreparedStatement ps = conn.prepareStatement(statement)) {
            ps.setInt(1, amount);
            ps.setString(2, ingredient_name);
            ps.setString(3, recipe_name);
            ps.executeUpdate();
        } catch(SQLException e) {
            e.printStackTrace();
        }
    }
    

    void insertIntoRestocks(String arrival_date, int amount, String ingredient_name) {
        String statement = "INSERT INTO restocks (arrival_date, amount, ingredient_name) VALUES (?, ?, ?);";

        try(PreparedStatement ps = conn.prepareStatement(statement)) {
            ps.setString(1, arrival_date);
            ps.setInt(2, amount);
            ps.setString(3, ingredient_name);
            ps.executeUpdate();
        } catch(SQLException e) {
            e.printStackTrace();
        }
    }

    void insertIntoPallets(String production_date, String expiration_date, int blocked, String state, String recipe_name) {
        String statement = "INSERT INTO pallets (production_date, expiration_date, blocked, state, recipe_name) VALUES (?, ?, ?, ?, ?);";

        try(PreparedStatement ps = conn.prepareStatement(statement)) {
            ps.setString(1, production_date);
            ps.setString(2, expiration_date);
            ps.setInt(3, blocked);
            ps.setString(4, state);
            ps.setString(5, recipe_name);
            ps.executeUpdate();
        } catch(SQLException e) {
            e.printStackTrace();
        }
    }

    void insertIntoOrders(int amount, String order_date, String last_delivery_date, int delivered, String customer_name) {
        String statement = "INSERT INTO orders (amount, order_date, last_delivery_date, delivered, customer_name) VALUES (?, ?, ?, ?, ?);";

        try(PreparedStatement ps = conn.prepareStatement(statement)) {
            ps.setInt(1, amount);
            ps.setString(2, order_date);
            ps.setString(3, last_delivery_date);
            ps.setInt(4, delivered);
            ps.setString(5, customer_name);
            ps.executeUpdate();
        } catch(SQLException e) {
            e.printStackTrace();
        }
    }




    void emptyDatabase() {
        int tablesize = 7;
        String[] tables = new String[tablesize];
        tables[0] = "restocks";
        tables[1] = "ingredients";
        tables[2] = "ingredients_used";
        tables[3] = "recipes";
        tables[4] = "pallets";
        tables[5] = "orders";
        tables[6] = "customers";


        for(int i = 0; i < tablesize; i++) {
            String statement = "DELETE FROM " + tables[i] + ";\n";
            try (PreparedStatement ps = conn.prepareStatement(statement)) {
                ps.executeUpdate();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

    String reset(Request req, Response res){

        res.type("application/json");
        emptyDatabase();
        
        insertIntoCustomers("Finkakor AB", "Helsingborg");
        insertIntoCustomers("Småbröd AB", "Malmö");
        insertIntoCustomers("Kaffebröd AB", "Landskrona");
        insertIntoCustomers("Bjukakor AB", "Ystad");
        insertIntoCustomers("Kalaskakor AB", "Trelleborg");
        insertIntoCustomers("Partykakor AB", "Kristianstad");
        insertIntoCustomers("Gästkakor AB", "Hässleholm");
        insertIntoCustomers("Skånekakor AB", "Perstorp");

        insertIntoIngredients("Flour", "g");
        insertIntoRestocks("2019-03-13", 100000, "Flour");
        insertIntoIngredients("Butter", "g");
        insertIntoRestocks("2019-03-13", 100000, "Butter");
        insertIntoIngredients("Icing sugar", "g");
        insertIntoRestocks("2019-03-13", 100000, "Icing sugar");
        insertIntoIngredients("Roasted, chopped nuts", "g");
        insertIntoRestocks("2019-03-13", 100000, "Roasted, chopped nuts");
        insertIntoIngredients("Fine-ground nuts", "g");
        insertIntoRestocks("2019-03-13", 100000, "Fine-ground nuts");
        insertIntoIngredients("Ground, roasted nuts", "g");
        insertIntoRestocks("2019-03-13", 100000, "Ground, roasted nuts");
        insertIntoIngredients("Bread crumbs", "g");
        insertIntoRestocks("2019-03-13", 100000, "Bread crumbs");
        insertIntoIngredients("Sugar", "g");
        insertIntoRestocks("2019-03-13", 100000, "Sugar");
        insertIntoIngredients("Egg whites", "g");
        insertIntoRestocks("2019-03-13", 100000, "Egg whites");
        insertIntoIngredients("Chocolate", "g");
        insertIntoRestocks("2019-03-13", 100000, "Chocolate");
        insertIntoIngredients("Marzipan", "g");
        insertIntoRestocks("2019-03-13", 100000, "Marzipan");
        insertIntoIngredients("Eggs", "g");
        insertIntoRestocks("2019-03-13", 100000, "Eggs");
        insertIntoIngredients("Potato starch", "g");
        insertIntoRestocks("2019-03-13", 100000, "Potato starch");
        insertIntoIngredients("Wheat flour", "g");
        insertIntoRestocks("2019-03-13", 100000, "Wheat flour");
        insertIntoIngredients("Sodium bicarbonate", "g");
        insertIntoRestocks("2019-03-13", 100000, "Sodium bicarbonate");
        insertIntoIngredients("Vanilla", "g");
        insertIntoRestocks("2019-03-13", 100000, "Vanilla");
        insertIntoIngredients("Chopped almonds", "g");
        insertIntoRestocks("2019-03-13", 100000, "Chopped almonds");
        insertIntoIngredients("Cinnamon", "g");
        insertIntoRestocks("2019-03-13", 100000, "Cinnamon");
        insertIntoIngredients("Vanilla sugar", "g");
        insertIntoRestocks("2019-03-13", 100000, "Vanilla sugar");
    
        insertIntoRecipes("Nut ring");
        insertIntoRecipes("Nut cookie");
        insertIntoRecipes("Amneris");
        insertIntoRecipes("Tango");
        insertIntoRecipes("Almond delight");
        insertIntoRecipes("Berliner");

        insertIntoIngredientsUsed(450, "Flour", "Nut ring");
        insertIntoIngredientsUsed(450, "Butter", "Nut ring");
        insertIntoIngredientsUsed(190, "Icing sugar", "Nut ring");
        insertIntoIngredientsUsed(225, "Roasted, chopped nuts", "Nut ring");

        insertIntoIngredientsUsed(750, "Fine-ground nuts", "Nut cookie");
        insertIntoIngredientsUsed(625, "Ground, roasted nuts", "Nut cookie");
        insertIntoIngredientsUsed(125, "Bread crumbs", "Nut cookie");
        insertIntoIngredientsUsed(375, "Sugar", "Nut cookie");
        insertIntoIngredientsUsed(350, "Egg whites", "Nut cookie");
        insertIntoIngredientsUsed(50, "Chocolate", "Nut cookie");

        insertIntoIngredientsUsed(750, "Marzipan", "Amneris");
        insertIntoIngredientsUsed(250, "Butter", "Amneris");
        insertIntoIngredientsUsed(250, "Egg", "Amneris");
        insertIntoIngredientsUsed(25, "Potato starch", "Amneris");
        insertIntoIngredientsUsed(25, "Wheat flour", "Amneris");

        insertIntoIngredientsUsed(200, "Butter", "Tango");
        insertIntoIngredientsUsed(250, "Sugar", "Tango");
        insertIntoIngredientsUsed(300, "Flour", "Tango");
        insertIntoIngredientsUsed(4, "Sodium bicarbonate", "Tango");
        insertIntoIngredientsUsed(2, "Vanilla", "Tango");

        insertIntoIngredientsUsed(400, "Butter", "Almond delight");
        insertIntoIngredientsUsed(270, "Sugar", "Almond delight");
        insertIntoIngredientsUsed(279, "Chopped almonds", "Almond delight");
        insertIntoIngredientsUsed(400, "Flour", "Almond delight");
        insertIntoIngredientsUsed(10, "Cinnamon", "Almond delight");

        insertIntoIngredientsUsed(350, "Flour", "Berliner");
        insertIntoIngredientsUsed(250, "Butter", "Berliner");
        insertIntoIngredientsUsed(100, "Icing sugar", "Berliner");
        insertIntoIngredientsUsed(50, "Eggs", "Berliner");
        insertIntoIngredientsUsed(5, "Vanilla sugar", "Berliner");
        insertIntoIngredientsUsed(50, "Chocolate", "Berliner");
        
        res.status(200);
        return res.toString();
    }

    String getMovies(Request req, Response res) {
        res.type("application/json");

        if(req.queryParams("title") != null && req.queryParams("year") != null) {
            res.status(200);
            return getMovie(req, res);
        }

        String query =
            "SELECT imdbKey, title, year\n" +
            "FROM   movies\n" +
            "WHERE  1 = 1\n";

        try (PreparedStatement ps = conn.prepareStatement(query)) {
            ResultSet rs = ps.executeQuery();
            String result = JSONizer.toJSON(rs, "data");
            res.status(200);
            res.body(result);
            return result;
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return "Movies not retrieved";
    }

    String getMovie(Request req, Response res) {
        res.type("application/json");
        String title = req.queryParams("title");
        int year = Integer.parseInt(req.queryParams("year"));

        String query =
            "SELECT imdbKey, title, year\n" +
            "FROM   movies\n" +
            "WHERE  title = ? AND year = ?\n";

        try (PreparedStatement ps = conn.prepareStatement(query)) {
            ps.setString(1, title);
            ps.setInt(2, year);
            ResultSet rs = ps.executeQuery();
            String result = JSONizer.toJSON(rs, "data");
            res.status(200);
            res.body(result);
            return result;
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return "";
    }

    String getMovieById(Request req, Response res) {
        res.type("application/json");
        String id = req.params(":id");

        String query =
            "SELECT imdbKey, title, year\n" +
            "FROM   movies\n" +
            "WHERE  imdbKey = ?\n";

        try (PreparedStatement ps = conn.prepareStatement(query)) {
            ps.setString(1, id);
            ResultSet rs = ps.executeQuery();
            String result = JSONizer.toJSON(rs, "data");
            res.status(200);
            res.body(result);
            return result;
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return "";
    }

    String getPerformances(Request req, Response res) {
        res.type("application/json");

        String query =
            "SELECT *\n" +
            "FROM   performances\n" +
            "WHERE  1 = 1\n";

        try (PreparedStatement ps = conn.prepareStatement(query)) {
            ResultSet rs = ps.executeQuery();
            String result = JSONizer.toJSON(rs, "data");
            res.status(200);
            res.body(result);
            return result;
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return "Performances not retrieved";
    }

    String postPerformances(Request req, Response res) {
        res.type("application/json");

        if(req.queryParams("imdb") == null || req.queryParams("theater") == null 
        || req.queryParams("date") == null || req.queryParams("time") == null) {
            res.status(400);
            return "Insufficient parameters.";
        }

        String imdb = req.queryParams("imdb");
        String theater = req.queryParams("theater");
        String date = req.queryParams("date");
        String time = req.queryParams("time");
        String title = "";
        int year = 0;
        int seats = 0;

        // Check if theater exists
        String query =
            "SELECT *\n" +
            "FROM   theaters\n" +
            "WHERE  theater = ?\n";

        try (PreparedStatement ps = conn.prepareStatement(query)) {
            ps.setString(1, theater);
            ResultSet rs = ps.executeQuery();
            if(!rs.next()) {
                res.status(404);
                return "No such theater exists.";
            } else {
                seats = rs.getInt("capacity");
            }
        } catch(SQLException e) {
            e.printStackTrace();
        }

        // Check if movie exists
        query =
            "SELECT *\n" +
            "FROM   movies\n" +
            "WHERE  imdbKey = ?\n";

        try (PreparedStatement ps = conn.prepareStatement(query)) {
            ps.setString(1, imdb);
            ResultSet rs = ps.executeQuery();
            if(rs.next() == false) {
                res.status(404);
                return "No such movie exists.";
            } else {
                year = rs.getInt("year");
                title = rs.getString("title");
            }
        } catch(SQLException e) {
            e.printStackTrace();
        }

        // Post performance
        String statement =
            "INSERT\n" +
            "INTO    performances(date, time, title, year, theater, remaining)\n" +
            "VALUES  (?, ?, ?, ?, ?, ?)";

        try (PreparedStatement ps = conn.prepareStatement(statement)) {
            ps.setString(1, date);
            ps.setString(2, time);
            ps.setString(3, title);
            ps.setInt(4, year);
            ps.setString(5, theater);
            ps.setInt(6, seats);
            ps.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }

        // Get ID and return
        query =
            "SELECT performanceId\n" +
            "FROM   performances\n" +
            "WHERE  1 = 1\n";

        try (PreparedStatement ps = conn.prepareStatement(query)) {
            ResultSet rs = ps.executeQuery();
            if (rs.next()) {
                String id = rs.getString("performanceId");
                String result = String.format("{ 'id': %s }", id);
                res.status(201);
                res.body(result);
                return String.format("%s", id);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }

        return "done?";
    }




    String postTickets(Request req, Response res) {
        String user = req.queryParams("user");
        String performance = req.queryParams("performance");
        String pwd = req.queryParams("pwd");
        String hashPwd = phg.hash(pwd);
        int seats = 0;
        int tickets = 0;

        // Authenticate user
        String query = 
        "SELECT password\n" +
        "FROM customers\n" +
        "WHERE username = ?";

        try(PreparedStatement ps = conn.prepareStatement(query)) {
            ps.setString(1, user);
            ResultSet rs = ps.executeQuery();
            if (rs.next()) {
                if(!hashPwd.equals(rs.getString("password"))) {
                    res.status(400);
                    return "Wrong password";
                }
            } else {
                return "Wrong username.";
            }
        } catch(SQLException e) {
            e.printStackTrace();
        }

        // Check if performance exists and check seats available
        query = 
        "SELECT *\n" +
        "FROM performances\n" +
        "WHERE performanceId = ?";

        try(PreparedStatement ps = conn.prepareStatement(query)) {
            ps.setString(1, performance);
            ResultSet rs = ps.executeQuery();
            if (!rs.next()) {
                return "No such performance!";
            } else {
                seats = rs.getInt("remaining");
            }
        } catch(SQLException e) {
            e.printStackTrace();
        }
        
        if(seats < 1) {
            return "No tickets left";
        }
        
        // Update seats
        String statement =
            "UPDATE performances\n" +
            "set    remaining = ?" +
            "WHERE  performanceId = ?";

        try (PreparedStatement ps = conn.prepareStatement(statement)) {
            ps.setInt(1, seats-1);
            ps.setString(2, performance);
            ps.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }



        // Get amount of customer tickets
        query = 
        "SELECT *\n" +
        "FROM tickets\n" +
        "WHERE username = ?";

        try(PreparedStatement ps = conn.prepareStatement(query)) {
            ps.setString(1, user);
            ResultSet rs = ps.executeQuery();
            while (rs.next()) {
                tickets++;
            }
        } catch(SQLException e) {
            e.printStackTrace();
        }

        // Update customer
        statement =
            "UPDATE customers\n" +
            "set    nbrOfTickets = ?\n" +
            "WHERE username = ?";

        try (PreparedStatement ps = conn.prepareStatement(statement)) {
            ps.setInt(1, tickets + 1);
            ps.setString(2, user);
            ps.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }


        // Post ticket
                statement =
                "INSERT\n" +
                "INTO    tickets(username, performanceId)\n" +
                "VALUES  (?, ?)";
    
            try (PreparedStatement ps = conn.prepareStatement(statement)) {
                ps.setString(1, user);
                ps.setString(2, performance);
                ps.executeUpdate();
            } catch (SQLException e) {
                e.printStackTrace();
            }

        // Get ID and return
        query =
            "SELECT t_id\n" +
            "FROM   tickets\n" +
            "WHERE  1 = 1\n";

        try (PreparedStatement ps = conn.prepareStatement(query)) {
            ResultSet rs = ps.executeQuery();
            if (rs.next()) {
                String id = rs.getString("t_id");
                String result = String.format("{ 'id': %s }", id);
                res.status(201);
                res.body(result);
                return String.format("/tickets/%s", id);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }



        return "Error";
    }

    String getCustomerTickets(Request req, Response res) {
        String id = req.params(":id");

         // Get ID and return
        String query =
            "SELECT nbrOfTickets, date, time, theater, title, year\n" +
            "FROM   customers\n" +
            "JOIN   tickets\n" +
            "USING  (username)" +
            "JOIN   performances\n" +
            "USING  (performanceId)" +
            "JOIN   movies\n" +
            "USING  (title, year)";

        try (PreparedStatement ps = conn.prepareStatement(query)) {
            ResultSet rs = ps.executeQuery();
            String result = JSONizer.toJSON(rs, "data");
            res.status(201);
            res.body(result);
            return result;
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return "Error";
    }

}



/**
 * Auxiliary class for automatically translating a ResultSet to JSON
 */
class JSONizer {

    public static String toJSON(ResultSet rs, String name) throws SQLException {
        StringBuilder sb = new StringBuilder();
        ResultSetMetaData meta = rs.getMetaData();
        boolean first = true;
        sb.append("{\n");
        sb.append("  \"" + name + "\": [\n");
        while (rs.next()) {
            if (!first) {
                sb.append(",");
                sb.append("\n");
            }
            first = false;
            sb.append("    {");
            for (int i = 1; i <= meta.getColumnCount(); i++) {
                String label = meta.getColumnLabel(i);
                String value = getValue(rs, i, meta.getColumnType(i));
                sb.append("\"" + label + "\": " + value);
                if (i < meta.getColumnCount()) {
                    sb.append(", ");
                }
            }
            sb.append("}");
        }
        sb.append("\n");
        sb.append("  ]\n");
        sb.append("}\n");
        return sb.toString();
    }
	
    private static String getValue(ResultSet rs, int i, int columnType) throws SQLException {
        switch (columnType) {
        case java.sql.Types.INTEGER:
            return String.valueOf(rs.getInt(i));
        case java.sql.Types.REAL:
        case java.sql.Types.DOUBLE:
        case java.sql.Types.FLOAT:
            return String.valueOf(rs.getDouble(i));
        default:
            return "\"" + rs.getString(i) + "\"";
        }
    }
}




class PasswordHashGenerator {

    public static String hash(String text) {
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            md.update(text.getBytes(StandardCharsets.UTF_8));
            byte[] digest = md.digest();
            return String.format("%064x", new BigInteger(1, digest));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}