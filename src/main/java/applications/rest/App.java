/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package applications.rest;

import java.sql.*;
import java.util.*;
import spark.*;
import static spark.Spark.*;
import com.google.gson.Gson;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.nio.charset.StandardCharsets;
import java.math.BigInteger;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;


public class App {

    public static void main(String[] args) {
        Database db = new Database("theater-chain.sqlite");
        port(7007);

        // Routes
        get("/ping", (req, res) -> r_ping(req, res));
        get("/movies", (req, res) -> db.getMovies(req, res));
        get("/movies/:id", (req, res) -> db.getMovieById(req, res));
        get("/performances", (req, res) -> db.getPerformances(req, res));
        post("/performances", (req, res) -> db.postPerformances(req, res));
        post("/reset", (req, res) -> db.reset(req, res));
    }

    /*  ROUTE: /ping
     *  DESC: Returns string Pong
     */ 
    public static String r_ping(Request req, Response res) {
        res.status(200);
        res.body("Ping");
        return res.body();
    }
}



class Database {

    /**
     * The database connection.
     */
    private Connection conn;

    /**
     * Creates the database interface object. Connection to the
     * database is performed later.
     */
    public Database(String filename) {
        openConnection(filename);
    }

    /**
     * Opens a connection to the database, using the specified
     * filename (if we'd used a traditional DBMS, such as PostgreSQL
     * or MariaDB, we would have specified username and password
     * instead).
     */
    public boolean openConnection(String filename) {
        try {
            Class.forName("org.sqlite.JDBC");
            conn = DriverManager.getConnection("jdbc:sqlite:" + filename);
        } catch (SQLException e) {
            e.printStackTrace();
            return false;
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }

    /**
     * Closes the connection to the database.
     */
    public void closeConnection() {
        try {
            if (conn != null) {
                conn.close();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    /**
     * Checks if the connection to the database has been established
     * 
     * @return true if the connection has been established
     */
    public boolean isConnected() {
        return conn != null;
    }

    /* ================================== */
    /* --- insert your own code below --- */
    /* ===============================*== */

    String getMovies(Request req, Response res) {
        res.type("application/json");

        if(req.queryParams("title") != null && req.queryParams("year") != null) {
            res.status(200);
            return getMovie(req, res);
        }

        String query =
            "SELECT *\n" +
            "FROM   movies\n" +
            "WHERE  1 = 1\n";

        try (PreparedStatement ps = conn.prepareStatement(query)) {
            ResultSet rs = ps.executeQuery();
            String result = JSONizer.toJSON(rs, "data");
            res.status(200);
            res.body(result);
            return result;
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return "Movies not retrieved";
    }

    String getMovie(Request req, Response res) {
        res.type("application/json");
        String title = req.queryParams("title");
        int year = Integer.parseInt(req.queryParams("year"));

        String query =
            "SELECT imdb_key, movie_name AS name, production_year AS year\n" +
            "FROM   movies\n" +
            "WHERE  movie_name = ? AND year = ?\n";

        try (PreparedStatement ps = conn.prepareStatement(query)) {
            ps.setString(1, title);
            ps.setInt(2, year);
            ResultSet rs = ps.executeQuery();
            String result = JSONizer.toJSON(rs, "data");
            res.status(200);
            res.body(result);
            return result;
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return "";
    }

    String getMovieById(Request req, Response res) {
        res.type("application/json");
        String id = req.params(":id");

        String query =
            "SELECT imdb_key, movie_name AS name, production_year AS year\n" +
            "FROM   movies\n" +
            "WHERE  imdb_key = ?\n";

        try (PreparedStatement ps = conn.prepareStatement(query)) {
            ps.setString(1, id);
            ResultSet rs = ps.executeQuery();
            String result = JSONizer.toJSON(rs, "data");
            res.status(200);
            res.body(result);
            return result;
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return "";
    }

    String getPerformances(Request req, Response res) {
        res.type("application/json");

        String query =
            "SELECT *\n" +
            "FROM   performances\n" +
            "WHERE  1 = 1\n";

        try (PreparedStatement ps = conn.prepareStatement(query)) {
            ResultSet rs = ps.executeQuery();
            String result = JSONizer.toJSON(rs, "data");
            res.status(200);
            res.body(result);
            return result;
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return "Performances not retrieved";
    }

    String postPerformances(Request req, Response res) {
        res.type("application/json");

        if(req.queryParams("imdb") == null || req.queryParams("theater") == null 
        || req.queryParams("date") == null || req.queryParams("time") == null) {
            res.status(400);
            return "Insufficient parameters.";
        }

        String imdb = req.queryParams("imdb");
        String theater = req.queryParams("theater");
        String date = req.queryParams("date");
        String time = req.queryParams("time");

        // Check if theater exists
        String query =
            "SELECT *\n" +
            "FROM   theaters\n" +
            "WHERE  theater_name = ?\n";

        try (PreparedStatement ps = conn.prepareStatement(query)) {
            ps.setString(1, theater);
            ResultSet rs = ps.executeQuery();
            if(rs.next() == false) {
                res.status(404);
                return "No such theater exists.";
            }
        } catch(SQLException e) {
            e.printStackTrace();
        }

        // Check if movie exists
        query =
            "SELECT *\n" +
            "FROM   movies\n" +
            "WHERE  imdb_key = ?\n";

        try (PreparedStatement ps = conn.prepareStatement(query)) {
            ps.setString(1, imdb);
            ResultSet rs = ps.executeQuery();
            if(rs.next() == false) {
                res.status(404);
                return "No such movie exists.";
            }
        } catch(SQLException e) {
            e.printStackTrace();
        }

        // Post performance
        String statement =
            "INSERT\n" +
            "INTO    performances(imdb_key, theater_name, start_date, start_time)\n" +
            "VALUES  (?, ?, ?, ?)";

        try (PreparedStatement ps = conn.prepareStatement(statement)) {
            ps.setString(1, imdb);
            ps.setString(2, theater);
            ps.setString(3, date);
            ps.setString(4, time);
            ps.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }

        // Get ID and return
        query =
            "SELECT performance_id\n" +
            "FROM   performances\n" +
            "WHERE  1 = 1\n";

        try (PreparedStatement ps = conn.prepareStatement(query)) {
            ResultSet rs = ps.executeQuery();
            if (rs.next()) {
                String id = rs.getString("performance_id");
                String result = String.format("{ 'id': %s }", id);
                res.status(201);
                res.body(result);
                return String.format("/performances/%s", id);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }

        return "done?";
    }

    String reset(Request req, Response res){
        PasswordHashGenerator phg = new PasswordHashGenerator();
        res.type("application/json");
        String[] tables = new String[5];
        tables[0] = "customers";
        tables[1] = "movies";
        tables[2] = "performances";
        tables[3] = "tickets";
        tables[4] = "theaters";

        for(int i = 0; i < 5; i++) {
            String statement = "DELETE FROM " + tables[i] + ";\n";
            try (PreparedStatement ps = conn.prepareStatement(statement)) {
                ps.executeUpdate();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        
        String customer1 = "INSERT INTO customers VALUES (?, ?, ?);\n";
        String customer2 = "INSERT INTO customers VALUES (?, ?, ?);\n";

        String movie1 = "INSERT INTO movies(movie_name, production_year, imdb_key) VALUES (?, ?, ?);\n";
        String movie2 = "INSERT INTO movies(movie_name, production_year, imdb_key) VALUES (?, ?, ?);\n";
        String movie3 = "INSERT INTO movies(movie_name, production_year, imdb_key) VALUES (?, ?, ?);\n";
        String theater1 = "INSERT INTO theaters VALUES (?, ?);\n";
        String theater2 = "INSERT INTO theaters VALUES (?, ?);\n";
        String theater3 = "INSERT INTO theaters VALUES (?, ?);\n";
         





      try {
            PreparedStatement cust1 = conn.prepareStatement(customer1);
            PreparedStatement cust2 = conn.prepareStatement(customer2);
            PreparedStatement mov1 = conn.prepareStatement(movie1);
            PreparedStatement mov2 = conn.prepareStatement(movie2);
            PreparedStatement mov3 = conn.prepareStatement(movie3);
            PreparedStatement theat1 = conn.prepareStatement(theater1);
            PreparedStatement theat2 = conn.prepareStatement(theater2);
            PreparedStatement theat3 = conn.prepareStatement(theater3);

            cust1.setString(1, "alice");
            cust1.setString(2, "Alice");
            cust1.setString(3, phg.hash("dobido"));
            cust2.setString(1, "bob");
            cust2.setString(2, "Bob");
            cust2.setString(3, phg.hash("whatsinaname"));
            mov1.setString(1, "The Shape of Water");
            mov1.setInt(2, 2017);
            mov1.setString(3, "tt5580390");
            mov2.setString(1, "Moonlight");
            mov2.setInt(2, 2016);
            mov2.setString(3, "tt4975722");
            mov3.setString(1, "Spotlight");
            mov3.setInt(2, 2015);
            mov3.setString(3, "tt1895587");
            theat1.setString(1, "Kino");
            theat1.setInt(2, 10);
            theat2.setString(1, "Södran");
            theat2.setInt(2, 16);
            theat3.setString(1, "Skandia");
            theat3.setInt(2, 100);

            cust1.executeUpdate();
            cust2.executeUpdate();
            mov1.executeUpdate();
            mov2.executeUpdate();
            mov3.executeUpdate();
            theat1.executeUpdate();
            theat2.executeUpdate();
            theat3.executeUpdate();

        } catch (SQLException e) {
            e.printStackTrace();
        }
        return "done?";
    }

    public String read_file(String fileLocation) throws IOException {
        try {
            BufferedReader in = new BufferedReader(new FileReader(fileLocation));
            String str;
            StringBuffer sb = new StringBuffer();
            while ((str = in.readLine()) != null) {
                sb.append(str + "\n ");
            }
            in.close();
            return sb.toString();
        } catch(Exception e) {
            e.printStackTrace();
        }
        return "Error while reading reset";
    }
}



/**
 * Auxiliary class for automatically translating a ResultSet to JSON
 */
class JSONizer {

    public static String toJSON(ResultSet rs, String name) throws SQLException {
        StringBuilder sb = new StringBuilder();
        ResultSetMetaData meta = rs.getMetaData();
        boolean first = true;
        sb.append("{\n");
        sb.append("  \"" + name + "\": [\n");
        while (rs.next()) {
            if (!first) {
                sb.append(",");
                sb.append("\n");
            }
            first = false;
            sb.append("    {");
            for (int i = 1; i <= meta.getColumnCount(); i++) {
                String label = meta.getColumnLabel(i);
                String value = getValue(rs, i, meta.getColumnType(i));
                sb.append("\"" + label + "\": " + value);
                if (i < meta.getColumnCount()) {
                    sb.append(", ");
                }
            }
            sb.append("}");
        }
        sb.append("\n");
        sb.append("  ]\n");
        sb.append("}\n");
        return sb.toString();
    }
	
    private static String getValue(ResultSet rs, int i, int columnType) throws SQLException {
        switch (columnType) {
        case java.sql.Types.INTEGER:
            return String.valueOf(rs.getInt(i));
        case java.sql.Types.REAL:
        case java.sql.Types.DOUBLE:
        case java.sql.Types.FLOAT:
            return String.valueOf(rs.getDouble(i));
        default:
            return "\"" + rs.getString(i) + "\"";
        }
    }
}




class PasswordHashGenerator {

    public static String hash(String text) {
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            md.update(text.getBytes(StandardCharsets.UTF_8));
            byte[] digest = md.digest();
            return String.format("%064x", new BigInteger(1, digest));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}